#include <iostream>#include <queue>#include <vector>struct sol {    int x, y;    int from;public:    sol(int x, int y, int from) {        this->x = x;        this->y = y;        this->from = from;    }};int main() {    int m, n;    int sx, sy;    int ex, ey;    std::cin >> m >> n >> sx >> sy >> ex >> ey;    int maze[20][20];    for (int i = 0; i < m; i++) {        for (int j = 0; j < n; ++j) {            scanf("%d", &maze[i][j]);        }    }    std::vector<sol> path;    std::queue<sol> queue;    queue.push(sol(sx, sy, -1));    maze[sx][sy] = 1;    while (!queue.empty()) {        sol a = queue.front();        queue.pop();        path.push_back(a);        if (a.x == ex && a.y == ey) {            break;        }        int from = path.size() - 1;        if (a.x >= 1 && maze[a.x - 1][a.y] == 0) {            maze[a.x - 1][a.y] = 1;            queue.push(sol(a.x - 1, a.y, from));        }        if (a.y >= 1 && maze[a.x][a.y - 1] == 0) {            maze[a.x][a.y - 1] = 1;            queue.push(sol(a.x, a.y - 1, from));        }        if (a.x < m - 1 && maze[a.x + 1][a.y] == 0) {            maze[a.x + 1][a.y] = 1;            queue.push(sol(a.x + 1, a.y, from));        }        if (a.y < n - 1 && maze[a.x][a.y + 1] == 0) {            maze[a.x][a.y + 1] = 1;            queue.push(sol(a.x, a.y + 1, from));        }    }    int index = path.size() - 1;    int sum = 0;    do {        index = path[index].from;        sum++;    } while (index != 0);    std::cout << sum;    return 0;}